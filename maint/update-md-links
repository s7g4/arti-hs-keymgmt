#!/usr/bin/env python3
#
# Usage:
#
#   maint/update-md-links CHANGELOG.md
#
# Updates a markdown file, merging/inserting links from `gen_md_links`
#
# New links are added to the next to the first place in the file
# where links are defined.
#
# When we don't know what a link target should be, we emit XXXX.


# ALGORITHM
#
# Look for annotations in the file telling us how to wirk.
#
# Split the file up into sections (divided by the specified heading level).
#
# In each section, find existing link def lines
# (ie, lines giving the target `t` for a link anchor text `a`).
# This gives us
#   - for each section
#     - for each anchor, locations of relevant defs in this section
#   - targets for some anchors
#
# Feed each section separately to gen_md_links
# This gives us
#   - for each section, needed anchor set
#   - targets, for some anchors
#
# Reconcile definitions, to obtain precisely one target for each anchor.
#
# for each section.
#   For each needed anchor
#     If there are def(s) in this section, before the def collection, OK
#     Otherwise write a a definition line to the new collection
#   Collect defs from existing final link def collection (if any)
#   Sort the collection
#   Replace the relevant part of the file with the normalised collection
#   (possibly *adding* the collection)

import argparse
import collections
import os
import re
import subprocess
import sys
import tempfile

link_def_re = re.compile(r'\[([^][]+)\]\:\s?(.*)\n?')
heading_re = re.compile(r'(\#+)\s')
instruction_re = re.compile(r'\<\!\-\-\@\@\s+update-md-links\s*(.*\S)\s*\-\-\>\s*$')
instruction_val_re = re.compile(r'\s*([-0-9a-z]+)\s+(.*\S)\s*')

instructions = {
    'split-heading-level': 0,
    'section-blank-lines': 1,
}

parser = argparse.ArgumentParser(
    prog="update-md-links",
    description="update links in a markdown document",
)
parser.add_argument('filename')
parser.add_argument('--check', action='store_true',
                    help='Check that everything is up to date; make no changes')

args = parser.parse_args()

md = list(open(args.filename, 'r'))

link_defs = {}

Def = collections.namedtuple('Def', ['t', 'source', 'md_i'])

sections = []
# namedtuple has defaults= but it gives every fresh tuple an aliased copy of the
# same value!
Section = collections.namedtuple('Section', ['start', 'end', 'defs_t2i', 'a_needed'])
def new_section(start, end):
    sections.append(Section(start, end, {}, {}))

troubles = 0

def trouble(m):
    global troubles
    print("trouble: "+m, file=sys.stderr)
    troubles += 1

def is_link_def(l):
    # returns None or (a, t)
    g = link_def_re.fullmatch(l)
    if g is None: return None
    return g.groups()

def record_link_def(a, t, source, md_i):
    link_defs.setdefault(a, []).append(Def(t, source, md_i))

#---------- search for instructions ----------

for i in range(0, len(md)):
    l = md[i]
    source = '%s:%d' % (args.filename, i + 1)

    g = instruction_re.fullmatch(l)
    if not g: continue

    g = instruction_val_re.fullmatch(g.group(1))
    if g:
        k, v = g.groups()
        if k not in instructions:
            trouble('%s: unknown value instruction %s' % (source, k))
        instructions[k] = v
        continue

    trouble('%s: unknown instruction' % source)

#---------- break input into sections ----------

section_start = 0
link_defs = {}

for i in range(0, len(md)):
    l = md[i]
    lno = i + 1

    g = heading_re.match(l)
    if g and len(g.group(1)) == int(instructions['split-heading-level']):
        if i != section_start:
            new_section(section_start, i)
        section_start = i

new_section(section_start, len(md))

for s in sections:
    #---------- for each section, find existing link def lines ----------

    for i in range(s.start, s.end):
        lno = i + 1
        l = md[i]
        at = is_link_def(l)
        if at:
            a, t = at
            record_link_def(a, t, "%s:%d" % (args.filename, lno), i)
            s.defs_t2i.setdefault(t, []).append(i)

    #---------- for each section, run gen_md_links ----------

    text_file = tempfile.TemporaryFile(mode = 'w+', buffering=True)
    for i in range(s.start, s.end):
        print(md[i], file=text_file)
    text_file.flush()
    text_file.seek(0, 0)
    gen_links_output = subprocess.Popen(
        ['maint/gen_md_links', '--', '-'],
        stdin=text_file, stdout=subprocess.PIPE, encoding='utf-8',
    )
    for l in gen_links_output.stdout:
        l = l.strip()
        if l == "": continue
        at = is_link_def(l)
        if at is None:
            print('gen_md_links produced bad output line %s (for %s:%d..%d)'
                  % (repr(l), args.filename, s.start+1, s.end),
                  file=sys.stderr)
            sys.exit(12)
        a, t = at
        record_link_def(a, t, "gen_md_links", None)
        s.a_needed[a] = True

    gen_links_output.wait()
    assert(gen_links_output.returncode == 0)

#---------- reconcile definitions ----------

link_def = {}

for a, defs in link_defs.items():
    candidates = {}
    for d in defs:
        if d.t.strip() != "":
            candidates.setdefault(d.t, []).append(d.source)

    ts = list(candidates.keys())
    if len(ts) > 1:
        trouble("conflicting definitions for [%s]" % a)
        done = {}
        for d in defs:
            t = d.t
            if done.get(t): continue
            done[t] = True
            print("  candidate %s" % t, file=sys.stderr)
            for d in defs:
                if d.t != t: continue
                print("    defined %s" % d.source, file=sys.stderr)
    if len(ts) == 0:
        ts.append("XXXX")

    link_def[a] = ts[0]

#---------- collate outputs ----------

for s in sections:
    linkcoll_start = s.end
    while True:
        if linkcoll_start <= s.start: break
        prev = linkcoll_start-1
        prev_l = md[prev]
        if prev_l.strip() != "" and not is_link_def(prev_l):
            break
        linkcoll_start = prev

    if linkcoll_start <= s.start: continue # section contains only links, ignore it

    if not s.a_needed: continue # section contains no link anchors, ignore it

    # Now linkcoll_start is the start of the link collection for this section.
    # (Including blank lines either siude of the link collection.)

    new_collection = []

    for a in s.a_needed:
        found = False
        for d in link_defs[a]:
            i = d.md_i
            if i is None: continue
            if i < s.start or i >= linkcoll_start: continue
            found = True
            break
        if not found:
            new_collection.append("[%s]: %s\n" % (a, link_def[a]))

    # delete old collection
    for i in range(linkcoll_start, s.end):
        md[i] = ""

    o = ""
    if len(new_collection) != 0:
        new_collection.sort()
        o += "\n" + "".join(new_collection)

    if s.end != len(md):
        for i in range(0, int(instructions['section-blank-lines'])):
            o += "\n"

    md[linkcoll_start-1] += o

#---------- write output ----------

new_filename = "%s.tmp" % args.filename
output = open(new_filename, 'w', buffering=True)
for l in md:
    print(l, file=output, end='')
output.close()

if troubles != 0:
    print('trouble, not installing %s' % new_filename, file=sys.stderr)
    sys.exit(12)

if args.check:
    r = subprocess.run(['diff', '-u', '--', args.filename, new_filename])
    if r.returncode == 1:
        print('CHANGELOG links not up to date.', file=sys.stderr)
        sys.exit(1)
    assert(r.returncode == 0)
else:
    os.rename(new_filename, args.filename)
