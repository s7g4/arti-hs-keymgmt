# RPC cookie authentication

This is based on the Tor control port's cookie authentication mechanism.

It's meant for use over a connection to a TCP port on localhost.

We try to provide the property that if a client and a server successfully
complete this process, then each one knows that the other was able to read
a given secure cookie file on the filesystem.


## Preliminaries

Let P be the 32-byte non-terminated string
"====== arti-rpc-cookie-v1 ======".

We assume a secure `MAC(key, value)`, personalized with the string P
to prevent inter-protocol attacks

Let `Enc(S)` be the encoding of a byte string `S` formed by
prepending the length of `S` as a two-byte big-endian integer to S.

> (For example, Enc("hello") is `[00 05 68 65 6c 6c 6f]`,
> and Enc("") is `[00 00]`.)

Let `A | B` indicate the concatenation of the strings A and B.

The client and server begin by knowing the location of a "cookie file."
That file contains a 32-byte fixed string P, followed by a 32-byte secret
`COOKIE` generated by the server. The server generates this file at startup.
Before connecting, the client reads this file,
and determines the value of `COOKIE`.

> Both parties need to make sure that the file isn't writeable by any
> untrusted user.  This is out-of-scope for this document.

Nothing here is NUL terminated unless explicitly specified otherwise.

## The protocol

At the start of the process, the client and server have the following inputs:
  - `SADDR_CANONICAL`: The address at which the server is listening.
    This must be exactly the same as it appears in the connect string.
  - `COOKIE`: The value of the cookie.

The client additionally knows:
  - `SADDR_USE`: The address at which to connect to the server.
    (It may be different from `SADDR_CANONICAL`
    if e.g. the client is running in a container.)

1. The client connects to the server at `SADDR_USE`.

   The client generates a random 32-byte nonce CN,
   and the server generates a random 32-byte nonce SN.
   These nonces MUST NOT be reused.

2. The client sends `CN`.

3. The server computes
   `CID = MAC(COOKIE, Enc("Server") | Enc(PORTS) | CN)`,
   and sends (`CID`, `SN`).

4. The client computes CID, and verifies that its value matches the one
   provided by the server.  If it does not match, it aborts the protocol.
   If it does match, the client computes
   `AUTH = MAC(COOKIE, Enc("Server") | Enc(PORTS) | SN)`.
   and sends `AUTH` to the server.

5. The client computes AUTH, and verifies that its value matches the one
   provided by the server.  If it does not match, it aborts the protocol.
   Otherwise, the parties are authenticated.

## In Arti-RPC.

This protocol is selected from an RPC connect string as discussed
in `rpc-connect-sketch.md` (see !2439 if it isn't merged yet.)

The client's message in step 2 is embedded in a `cookie_challenge` field in the client's
`auth:query` message.

The server's message in step 3 is embedded in the server's response to that
method, in a pair of fields `cookie_challenge` and `cookie_id`.

The client's method in step 3 is embedded in the client's authentication
message, in a field called `auth`.

All binary strings are encoded in hexadecimal before sending in JSON.

