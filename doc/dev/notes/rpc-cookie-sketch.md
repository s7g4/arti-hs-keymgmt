# RPC cookie authentication

This is based on the Tor control port's cookie authentication mechanism.

It's meant for use over a connection to a TCP port on localhost.

We try to provide the property that if a client and a server successfully
complete this process, then each one knows that the other was able to read
a given secure cookie file on the filesystem.


## Preliminaries

Let P be the 32-byte string
"====== arti-rpc-cookie-v1 ======".

Let MAC(a,b,c,...) be TupleHash,
the Keccak-based cryptographic digest function
described in Section 5 of [NIST SP 800-185],
using the output length `L = 256 bits`,
and the customization string `S = "arti-rpc-cookie-v1"`

> NOTE: Do not substitute any other hash function without cryptographic
> analysis!  In particular, we rely on TupleHash(K,a,b,c,d,...)
> instantiating a proper message-authentication-code over a unique
> encoding of the tuple `(a,b,c,d,...)`.

The client and server begin by knowing the location of a "cookie file."
That file contains a 32-byte fixed string P, followed by a 32-byte secret
`COOKIE` generated by the server. The server generates this file at startup.
Before connecting, the client reads this file,
and determines the value of `COOKIE`.

> Both parties need to make sure that the file isn't writeable by any
> untrusted user.  This is out-of-scope for this document.

Strings are represented in UTF-8 without a trailing NUL byte.

[NIST SP 800-185]: https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf

## The protocol

At the start of the process, the client and server have the following inputs:
  - `SADDR_CANONICAL`: The address at which the server is listening.
    This must be exactly the same string as the `socket` in the connect string.
  - `COOKIE`: The value of the cookie.

The client additionally knows:
  - `SADDR_USE`: The address at which to connect to the server.
    (It may be different from `SADDR_CANONICAL`
    if e.g. the client is running in a container.)

1. The client connects to the server at `SADDR_USE`.

   The client generates a random 32-byte nonce CN,
   and the server generates a random 32-byte nonce SN.
   These nonces MUST NOT be reused.

2. The client sends `CN`.

3. The server computes
   `S_MAC = MAC(COOKIE, "Server", SADDR_CANONICAL, CN)`
   and sends (`S_MAC`, `SADDR_CANONICAL`, `SN`).
   (See below for the encoding.)

4. The client computes `S_MAC`, and verifies that its value matches the one
   provided by the server.  If it does not match, it aborts the protocol.
   If it does match, the client computes
   `C_MAC = MAC(COOKIE, "Client", SADDR_CANONICAL, SN)`,
   and sends `C_MAC` to the server.

5. The server computes `C_MAC`, and verifies that its value matches the one
   provided by the client.  If it does not match, this connection attempt aborts.
   Otherwise, the parties are authenticated.

## In Arti-RPC.

This protocol is selected from an RPC connect string as discussed
in `rpc-connect-sketch.md` (see !2439 if it isn't merged yet.)

The client's message in step 2 is sent by invoking the `auth:cookie_begin` method,
implemented on the connection object.
It expects a single `client_nonce` parameter.

The server's message in step 3 is embedded in the server's response to that
method, in a set of fields: `server_addr`, `server_mac`, and `server_nonce.`
Additionally, the response includes an object ID in a `cookie_auth` field
This object holds the in-progress authentication state, and can be used
for a single `auth:cookie_continue` command.

The client's message in step 4 is sent by invoking the
`auth:cookie_continue` method,
directed to the object ID received in the `cookie_auth` field.
The `C_MAC` value is sent in a field called `client_mac`.

All binary values are encoded as hexadecimal strings before sending in JSON.

## Amendment to connect strings

When cookie authentication is in use, we may also specify `addr_canonical`
in the `cookie` object in the connect string.

This is an optional field.
When it is present, it is what the RPC client uses
in place of the `socket` address
during cookie authentication.

The RPC server ignores this field; it always binds to the address
in the `socket` field.

**Security concerns**: Do not construct a connect string with an
`addr_canonical` field unless you have some way to guarantee
that an attacker cannot bind to the address specified in the `socket`
field.

> (We'll merge this there once the dust has settled on arti!2439)
