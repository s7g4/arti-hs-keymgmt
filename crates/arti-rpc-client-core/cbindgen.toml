
# We emit a C header by default.
language = "C"

# We use this macro to prevent double-includes of our header.
include_guard = "ARTI_RPC_CLIENT_CORE_H_"

# This appears at the top of the file.
header = """\
/**
 * # Arti RPC core library header.
 *
 * (TODO RPC: This is still a work in progress; please don't rely on it
 * being the final API.)
 *
 * ## What this library does
 *
 * The Arti RPC system works by establishing connections to an Arti instance,
 * and then exchanging requests and replies in a format inspired by
 * JSON-RPC.  This library takes care of the work of connecting to an Arti
 * instance, authenticating, validating outgoing JSON requests, and matching
 * their corresponding JSON responses as they arrive.
 *
 * This library _does not_ do the work of creating well-formed requests,
 * or interpreting the responses.
 *
 * (Note: Despite this library being exposed via a set of C functions,
 * we don't actually expect you to use it from C.  It's probably a better
 * idea to wrap it in a higher-level language and then use it from there.)
 *
 * ## Using this library
 *
 * TODO RPC Explain better.
 *
 * Your connection to Arti is represented by an `ArtiRpcConn *`.  Use
 * `arti_connect()` to create one of these.
 *
 * Once you have a connection, you can sent Arti various requests in
 * JSON format.  See (TODO RPC: Add a link to a list of comments.)
 * Use `arti_rpc_execute()` to send a simple request; the function will
 * return when the request succeeds, or fails.
 *
 * TODO: Explain handles and other APIs once I add those APIs.
 *
 * Except when noted otherwise, all functions in this library are thread-safe.
 *
 * ## Error handling
 *
 * On success, fallible functions return `ARTI_SUCCESS`.  On failure,
 * they return some other error code, and store the most recent
 * error in thread-local state.
 *
 * You can access information about the most recent error
 * by calling `arti_err_{status,message,response}(NULL)`.
 * Alternatively, you can make a copy of the most recent error
 * by calling `arti_err_clone(NULL)`, and then passing the resulting error
 * to the `arti_err_{status,message,response}()` functions.
 *
 * ## Interface conventions
 *
 * - All functions check for NULL pointers in their arguments.
 *   - As in C tor, `foo_free()` functions treat `foo_free(NULL)` as a no-op
 *
 * - Fallible functions return an ArtiStatus.
 *
 * - All identifiers are prefixed with `arti`, in some case.
 *
 * ## Safety
 *
 * - Basic C safety requirements apply: every function's input pointers
 *   must point to valid data of the correct type.
 * - All input objects must not be mutated while they are in use.
 * - All input strings must obey the additional requirements of CStr::from_ptr:
 *   They must be valid for their entire extent, they must be no larger than SSIZE_MAX,
 *   they must be nul-terminated, and they must not be mutated while in use.
 * - In each case where pointers are passed, we explicitly state
 *   whether ownership is transferred.
 * ^ TODO RPC: Make sure we actually document this!
 **/"""

# This appears "between major sections"
autogen_warning = "/* Automatically generated by cbindgen. Don't modify manually. */"

# make sure our header can be included in C++.
cpp_compat = true

# Consistency with Arti.
tab_width = 8

[defines]
# This is where we would add mappings from `cfg()` to `#ifdef`.
# But the only relevant cfg we have is `cfg(feature="ffi")`,
# which we want to assume is always present if you're using the header.

[export]
# These structs are not ones we want to expose under their actual names,
# or ones that we don't want to expose at all.
exclude = ["RpcErrorCode", "RpcConn", "FfiError"]

[export.rename]
# Having not declared these structs, we can give them new names in the
# typedefs that assign them their real names.
"RpcConn" = "struct ArtiRpcConn"
"FfiError" = "struct ArtiError"

[fn]
# Lay out one argument per line.
args = "vertical"

[parse]

[parse.expand]
# We need to run our crate through macro expansion in order to get all
# of the right functions and constants.
#
# (Unfortunately, this requires us to use nightly rust, so that cbindgen
# can invoke rustc with `-Zunpretty=expanded`.)
crates = ["arti-rpc-client-core"]

# Run macro-expansion with --all-features so that we see `ffi`.
all_features = true
